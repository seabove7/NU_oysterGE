---
title: "Ocean acidification and boring sponge on *Crassostrea virginica* GE"
date: "*Last run on `r format(Sys.time(), '%d %B %Y')`*"
output: 
  html_document:
    theme: simplex
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: hide
---

---

<style>
  h2{color: #DC7633 !important}
  h1{color: #5499C7 !important}
  body{background-color: white !important}
</style>

<style>
.list-group-item.active, .list-group-item.active:hover, .list-group-item.active:focus {
    color: #212F3D;
    background-color: #EDBB99;
    font-weight: bold;}
a {
    color: #5499C7;}
.nav-tabs > li.active > a, .nav-tabs > li.active > a:hover, .nav-tabs > li.active > a:focus {
    color: #DC7633;}
body {
    font-family: "Open Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    font-size: 13px;
    line-height: 1.42857143;
    color: #212F3D;}
</style>

---

```{r setup, include = FALSE} 

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
options(knitr.kable.NA = '')

library("knitr")

date <- Sys.Date() # For saving with the current date
set.seed(7) # set seed


## Setting standard theme for ggplot for all plots:
theme_bove <- function(base_size = 14) {
  theme_bw(base_size = base_size) %+replace%
    theme(
      # remove the gridlines
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      # remove formatting on background
      strip.background = element_blank(),
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "transparent", colour = NA),
      # modify legend theme
      legend.position = "none",
      legend.background = element_rect(fill = "transparent", colour = "transparent"),
      legend.key = element_rect(fill = "transparent", colour = "transparent")
    )
}


## Source the custom functions file:
#source("Code/CustomFunctions.R")

```

```{r install packages, eval = FALSE, include = FALSE}

### If any packages are not installed or need to be updated, you can look for them below:
## get gridSVG from github directly
# library(devtools) 
# devtools::install_github("cran/gridSVG")
# devtools::install_github('sinhrks/ggfortify')
# devtools::install_github("ropensci/rnaturalearthhires")
# devtools::install_github("lpantano/DEGreport")

## get Bioconductor packages
if (!requireNamespace("BiocManager"))
install.packages("BiocManager")
BiocManager::install("DESeq2")

## installing WGCNA:
# source("http://bioconductor.org/biocLite.R")
BiocManager::install(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
BiocManager::install("WGCNA", dependencies=TRUE)
BiocManager::install("arrayQualityMetrics", dependencies=TRUE) # use this arrayQualityMetrics install if using later versions of R (3.6.3 works)
#repos="http://cran.us.r-project.org"

## R version 3.6 is funky with arrayQualityMetrics so need this work around:
install.packages("ape", lib = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
library(ape, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages("magick", lib = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library", dependencies = FALSE)
library(magick, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
BiocManager::install("arrayQualityMetrics", type = "source", checkBuilt = TRUE, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")



### Used packages that need to be installed to run code (and can be sourced easier from CRAN):
needed_packages <- c("tidyverse", "dplyr", "readr", "plotly", "vegan", "data.table", "ggpubr", "pdftools", "ggrepel", "adegenet") # Specify necessary packages

not_installed <- needed_packages[!(needed_packages %in% installed.packages()[ , "Package"])] # Extract not installed packages
if(length(not_installed)) install.packages(not_installed) # Install not installed packages

```

```{r load packages, include=FALSE}

library(tidyverse)
library(dplyr)
#library(arrayQualityMetrics) # need special install above
library(ggplot2)
library(readr)
library(plotly)
library(DESeq2) # need special install above
library(vegan)
library(data.table)
library(ggpubr)
library(pdftools)
library(ggrepel)
library(adegenet)
library(ggvenn)
library(flashClust)
library(WGCNA)
library(gridExtra)

source("Code/CustomFunctions.R")

#color scheme throughout
#n2800 n400 s2800 s400
color_scheme <- c("#2c7bb6", "#abd9e9", "#d7191c", "#fdae61")


```


## Expoloring data {.tabset}

```{r read in data}

# read in the counts file
counts <- read.table("Data/CVIR_featurecounts_23Sep22.txt", header = TRUE, row.names = 1)
counts <- counts[c(-1:-5, -37)] # removing columns 1-5 since we do not need them for this (and the Undetermined column)
col_names <- colnames(counts)

# Remove some of the extra stuff in the column names to match with expDesign
col_names <- gsub("X", "", col_names)
col_names <- gsub("\\_S.*", "", col_names)
colnames(counts) <- col_names

# read in the experimental design .csv
expDesign <- read.csv("Data/cvir_expDesign.csv")
expDesign <- expDesign[match(col_names, expDesign$Sample_ID),] # reorder samples to match count df
expDesign$infect <- factor(expDesign$infect)
expDesign$pCO2 <- factor(expDesign$pCO2)
expDesign$Sample_ID <- factor(expDesign$Sample_ID)
expDesign$treat <- factor(paste(expDesign$infect, expDesign$pCO2, sep = "_"))

```

<br/>

### Filtering counts

```{r unfiltered size factor plots, fig.width = 10, fig.height = 4}

nrow <- nrow(counts) # number of rows/counts (38828)
countMat <- DESeqDataSetFromMatrix(counts, expDesign, ~ 1) # makes a DESeqDataSet object with count data, experimental design, and no design formula
counts_SF <- estimateSizeFactors(countMat) #  estimates the size factors using the "median ratio method" described by Equation 5 in Anders and Huber (2010)

# make dataframe of the size factors to visualize
sizeFactors <- data.frame(sample = counts_SF@colData@listData[["Sample_ID"]], treat = counts_SF@colData@listData[["treat"]], sizeFactors = counts_SF@colData@listData[["sizeFactor"]])

# plot sizeFactors
ggplot(data = sizeFactors, aes(x = sample, y = sizeFactors, fill = treat)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_manual(values=color_scheme) +
  #scale_fill_brewer(palette = 2, type = "qual") +
  geom_bar(stat = "identity") +
  ggtitle("Unfiltered sizeFactors")

```

Figure 1: Size factors of initial oyster samples in the study, calculated using oyster gene count data.

After viewing the size factors, it appears that we have 5 samples with really low values that should be removed:

* 19355
* 19372
* 19382
* 19496
* 19505

<br/>


```{r filter low reads (base mean 3)}

### Filtered counts and remove outliers (less than 3)

## remove rows with no or low counts (remove ones with base mean lower than 3)
keep <- rowSums(counts(counts_SF)) >= 3
counts_filter <- counts[keep,]
nrow_filter <- nrow(counts_filter)
# the updated number of rows (21957)


## outliers removed based on array quality metrics
outs <- c(14, 16, 18, 23, 24, 28) # pull these outliers (19355 = #14, 19372 = #16, 19382 = #18, 19496 = #23, 19505 = #24, 19611	 = #28)
filter_counts_out <- counts_filter[,-outs]
expDesign <- expDesign[-outs,]

```

```{r filtered size factor plots, fig.width = 10, fig.height = 4}

## Redo the count matrix steps from above with the filtered data
filt_countMat <- DESeqDataSetFromMatrix(filter_counts_out, expDesign, ~ 1) # makes a DESeqDataSet object with count data, experimental design, and no design formula
counts_SF_filter <- estimateSizeFactors(filt_countMat) #  estimates the size factors using the "median ratio method" described by Equation 5 in Anders and Huber (2010)


# make dataframe of the size factors to visualize
sizeFactors_filter <-  data.frame(sample = counts_SF_filter@colData@listData[["Sample_ID"]], treat = counts_SF_filter@colData@listData[["treat"]], sizeFactors = counts_SF_filter@colData@listData[["sizeFactor"]])

# plot sizeFactors
ggplot(data = sizeFactors_filter, aes(x = sample, y = sizeFactors, fill = treat)) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_manual(values=color_scheme) +
  #scale_fill_brewer(palette = 2, type = "qual") +
  geom_bar(stat = "identity") +
  ggtitle("Filtered sizeFactors")

```

Figure 2: Size factors of oyster samples remaining in the study after 5 outliers were removed, calculated using oyster gene count data.

Without filtering low reads, we had a total of **`r nrow`** counts. After filtering out the low counts (those with a base mean less than 3), we now have **`r  nrow_filter`** counts remaining for all *C. virginica* samples.

<br/>
<br/>


### PCA plots of Global Gene Expression 

```{r dds model and save, eval = FALSE, echo = TRUE}

# going to use the filter_counts_out object created above because it is filtered for low reads and has outliers removed

## create the DESeq object
dds <- DESeqDataSetFromMatrix(countData = filter_counts_out, 
                              colData = expDesign,
                              design = ~ treat)
dds <- DESeq(dds) # differential expression analysis on gamma-poisson distribution
vsd <- varianceStabilizingTransformation(dds, blind = TRUE) # quickly estimate dispersion trend and apply a variance stabilizing transformation

## saving the rlog for DEG heatmap
rlog <- DESeq2::rlog(dds, blind = TRUE) #for use later on


## Save dds and vsd data 
save(dds, vsd, rlog, file = "Data/transformed_counts.RData")

```

```{r normalized count table}

## Load previously saved dds, vsd, and rlog data 
load("Data/transformed_counts.RData")

## Normalize counts for table
dds <- estimateSizeFactors(dds)
norm_counts <- counts(dds, normalized = TRUE)

```

```{r GE PCA, include=FALSE}

## calculate PCs based on the vsd transformed GE
pcaData <- plotPCA_allPCs(vsd, intgroup = c("treat", "pCO2", "infect"), ntop = 100, returnData = TRUE) # will provide all PCs
#head(pcaData)

# extract variance for all PCs
percentVar <- round((100 * attr(pcaData, "percentVar")), 2)

```


```{r PERMANOVA}

# run the PERMANOVA with euclidean distances and 1500 iterations
#head(pcaData[6:30])
GE_pca <- adonis2(pcaData[6:30] ~ pcaData$pCO2 + pcaData$infect, method = 'eu', permutations = 1500)
GE_pca

```

<br/>


```{r GE PCA plot, fig.align='center', fig.width = 4, fig.height = 3}

color_scheme_ordered <- c("#abd9e9", "#2c7bb6", "#fdae61", "#d7191c") 

## PCA: treatment effects (crossed)
pca_plot <- ggplot(pcaData, aes(x = PC1, y = PC2, color = treat)) +
  geom_point(size = 3, shape=21, aes(fill = treat),alpha = 0.8) +
  stat_ellipse(geom = "polygon", aes(colour = treat, fill = treat), fill = NA, type = "t", level = 0.95, alpha = 0.2, show.legend = FALSE) +
  xlab(paste0("PC1 (", percentVar[1], "%)")) +
  scale_fill_manual(name = "Treatment", values=color_scheme, labels = c("No sponge, pCO2 2800", "No sponge, pCO2 400", "Sponge, pCO2 2800", "Sponge, pCO2 400")) +
  scale_color_manual(name = "Treatment", values=color_scheme, labels = c("No sponge, pCO2 2800", "No sponge, pCO2 400", "Sponge, pCO2 2800", "Sponge, pCO2 400")) +
  ylab(paste0("PC2 (", percentVar[2], "%)")) +
  #scale_colour_brewer(palette = 2, type = "qual") +
  ggtitle("Top 100 genes") +
  theme_classic()

pca_plot

ggsave("Figures/FigureXX_GEpca.pdf", width = 6, height = 4)
ggsave("Figures/FigureXX_GEpca.png", width = 5, height = 3)



```

Figure 3: PCA plot with each point being one oyster sample colored by treatment. Light blue represents the control treatment (no infection, pCO2 level 400), dark blue represents no infection but high pCO2, dark red represents samples infected with boring sponge at pCO2 2800, and orange represents samples infected with boring sponge at pCO2 400.

<br/>
<br/>


## Differential gene expression {.tabset}

<br/>

### DEGs 

```{r general results of DEGs}

## Fist, we will look at the general 'results()' function
results(dds)
summary(results(dds))

```

```{r create results of DEGs by contrasts}

## When specifying your contrasts, make sure you 'control' level is the second value input and your 'treatment' is the first
res_con_sponge <- results(dds, contrast = c("treat", "S_400", "N_400"), alpha = 0.05)
res_con_pco2 <- results(dds, contrast = c("treat", "N_2800", "N_400"), alpha = 0.05)
res_trt <- results(dds, contrast = c("treat", "S_2800", "N_400"), alpha = 0.05)

##new
#res_trt_pco2 <- results(dds, contrast = c("treat", "S_2800", "S_400"), alpha = 0.05)
#res_stn_pco2 <- results(dds, contrast = c("treat", "S_400", "N_2800"), alpha = 0.05)
#res_shn_pco2 <- results(dds, contrast = c("treat", "S_2800", "N_2800"), alpha = 0.05)

```

```{r results summary, echo = TRUE}

summary(res_con_sponge) # when sponge is infected @ control pCO2
summary(res_con_pco2) # no sponge, but increasing pCO2
summary(res_trt) # higher pCO2 and sponge infection
#summary(res_trt_pco2)
#summary(res_stn_pco2)
#summary(res_shn_pco2)

```

```{r filter for DEGs}

## Filter for DEG per pairwise comparison (adjusted p value = 0.05)
# sponge v no sponge at control pCO2
downCon_S <- row.names(res_con_sponge[res_con_sponge$padj < 0.05 & !is.na(res_con_sponge$padj) & res_con_sponge$log2FoldChange < 0, ])
upCon_S <- row.names(res_con_sponge[res_con_sponge$padj < 0.05 & !is.na(res_con_sponge$padj) & res_con_sponge$log2FoldChange > 0, ])
allCon_S <- row.names(res_con_sponge[res_con_sponge$padj < 0.05 & !is.na(res_con_sponge$padj), ])

# pCO2 with no sponge
downTrt_N <- row.names(res_con_pco2[res_con_pco2$padj < 0.05 & !is.na(res_con_pco2$padj) & res_con_pco2$log2FoldChange < 0, ])
upTrt_N <- row.names(res_con_pco2[res_con_pco2$padj < 0.05 & !is.na(res_con_pco2$padj) & res_con_pco2$log2FoldChange > 0, ])
allTrt_N <- row.names(res_con_pco2[res_con_pco2$padj < 0.05 & !is.na(res_con_pco2$padj), ])

# control v double trt (sponge at high pCo2)
downTrt_S <- row.names(res_trt[res_trt$padj < 0.05 & !is.na(res_trt$padj) & res_trt$log2FoldChange < 0, ])
upTrt_S <- row.names(res_trt[res_trt$padj < 0.05 & !is.na(res_trt$padj) & res_trt$log2FoldChange > 0, ])
allTrt_S <- row.names(res_trt[res_trt$padj < 0.05 & !is.na(res_trt$padj), ]) 

# #sponge high vs sponge low
# downtrtS <- row.names(res_trt_pco2[res_trt_pco2$padj < 0.05 & !is.na(res_trt_pco2$padj) & res_trt$log2FoldChange < 0, ])
# uptrtS <- row.names(res_trt_pco2[res_trt_pco2$padj < 0.05 & !is.na(res_trt_pco2$padj) & res_trt$log2FoldChange > 0, ])
# 
# alltrtS <- row.names(res_trt_pco2[res_trt_pco2$padj < 0.05 & !is.na(res_trt_pco2$padj), ] )
# 
# #sponge low vs no sponge high
# downslsh <- row.names(res_stn_pco2[res_stn_pco2$padj < 0.05 & !is.na(res_stn_pco2$padj) & res_trt$log2FoldChange < 0, ])
# upslsh <- row.names(res_stn_pco2[res_stn_pco2$padj < 0.05 & !is.na(res_stn_pco2$padj) & res_trt$log2FoldChange > 0, ])
# 
# allslsh <- row.names(res_stn_pco2[res_stn_pco2$padj < 0.05 & !is.na(res_stn_pco2$padj), ])
# 
# #sponge high vs no sponge high
# downsshn <- row.names(res_shn_pco2[res_shn_pco2$padj < 0.05 & !is.na(res_shn_pco2$padj) & res_trt$log2FoldChange < 0, ])
# upsshn <- row.names(res_shn_pco2[res_shn_pco2$padj < 0.05 & !is.na(res_shn_pco2$padj) & res_trt$log2FoldChange > 0, ])
# 
# allsshn <- row.names(res_shn_pco2[res_shn_pco2$padj < 0.05 & !is.na(res_shn_pco2$padj), ])

## Compile DEG dataframe
DEG_bar <- data.frame("treat" = c(toString(unlist(str_split(res_con_sponge@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_con_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), toString(unlist(str_split(res_trt@elementMetadata@listData[["description"]][2], " "))[c(8,6)])), 
                "up" = c(length(upCon_S), length(upTrt_N), length(upTrt_S)), 
                "down" = c((length(downCon_S) * -1), (length(downTrt_N) * -1), (length(downTrt_S) * -1)))

#DEG_bar <- data.frame("treat" = c(toString(unlist(str_split(res_con_sponge@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), #toString(unlist(str_split(res_con_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), #toString(unlist(str_split(res_trt@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), #toString(unlist(str_split(res_trt_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), #toString(unlist(str_split(res_stn_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)]), #toString(unlist(str_split(res_shn_pco2@elementMetadata@listData[["description"]][2], " "))[c(8,6)])), 
#                "up" = c(length(upCon_S), length(upTrt_N), length(upTrt_S), length(uptrtS), length(upslsh), length(upsshn)), 
#                "down" = c((length(downCon_S) * -1), (length(downTrt_N) * -1), (length(downTrt_S) * -1), (length(downtrtS) * -1), (length(downslsh) * -1), (length(downsshn) * #-1)))

DEG_bar <- gather(DEG_bar, reg, genes, up:down)

split_stringfunc <- function(x) {
  toString(unlist(str_split(x@elementMetadata@listData[["description"]][2], " "))[c(8,6)])
}

split_stringfunc(res_trt)

```

```{r DEG plot}

## Plot bar graph of DEG

ggplot(data = DEG_bar, aes(x = treat, y = genes, fill = reg)) +
  theme_classic() +
  geom_bar(stat="identity") +
  scale_fill_manual(values = c("#2c7bb6", "#d7191c")) +
  geom_hline(yintercept = 0, linetype = "dashed", size=0.5) + 
  ylab("Sig DEGs") +
  theme(legend.position = "none", axis.text.x = element_text(angle = 90)) +
  xlab ("")

ggsave("Figures/FigureXX_DEGsBar.pdf", width = 6, height = 4)
ggsave("Figures/FigureXX_DEGsBar.png", width = 5, height = 4)

```

Figure: Bar plot of significant DEGs. The y axis denotes how many genes there are, with positive values being up-regulated genes, and negative values denoting down-regulated genes. 

<br/>
<br/>


### Paired Venns of DEGs

Colleen is dropping this since we don't have shared genes for now!

```{r paired Venns, eval=FALSE, include=FALSE}

## Comparing up NS_400 vs S_2800 and up NS_400 vs S_400
venn_loci_df <- list("NS_400 vs S_2800" = upTrt_S, "NS_400 vs S_400" = upTrt_N)



### Comparing up NS_400 vs S_2800 and up S_2800 vs NS_2800
#venn_loci_df <- list("NS_400 vs S_2800" = upTrt_S, "S_2800 vs NS_2800" = upsshn)
#
### Comparing up NS_400 vs S_2800 and up S_2800 vs NS_2800
#venn_loci_up <- list("NS_400 vs S_2800" = upTrt_S, "S_2800 vs S_400" = uptrtS)
#
### Comparing down NS_400 vs S_2800 and up S_2800 vs NS_2800
#venn_loci_down <- list("NS_400 vs S_2800" = downTrt_S, "S_2800 vs NS_2800" = downsshn)
#
### Comparing down NS_400 vs S_2800 and down S_2800 vs S_400
#venn_loci2_down <- list("NS_400 vs S_2800" = downTrt_S, "S_2800 vs S_400" = downtrtS)
#
### Comparing between all three
#venn_all <- list("Ctrl vs Sponge, pCO2 2800" = allTrt_S, "Ctrl vs No Sponge, pCO2 2800" = allTrt_N, "Ctrl vs Sponge, pCO2 400" = allCon_S)

## Plot the seperate venn diagrams
ven1 <- ggvenn(venn_loci_df, 
       show_percentage=FALSE,
       fill_color = c("darkorange", "coral"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "#C8322F", set_name_size = 2,
       )

ven2 <- ggvenn(venn_loci_up, 
       show_percentage=FALSE,
       fill_color = c("darkorange", "coral"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "#C8322F", set_name_size = 2,
       )

ven3 <- ggvenn(venn_loci_down, 
       show_percentage=FALSE,
       fill_color = c("cyan4", "cornflowerblue"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 2,
       )

ven4 <- ggvenn(venn_loci2_down, 
       show_percentage=FALSE,
       fill_color = c("cyan4", "cornflowerblue"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 2,
       )

ven5 <- ggvenn(venn_all, 
       show_percentage=FALSE,
       fill_color = c("#2c7bb6", "#fdae61", "#d7191c"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 7, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 3,
       )

ven5

## Combine and save plot
ggarrange(ven1, ven2, ven3, ven4, ven5)
ggsave("Figures/FigureXX_PairedVens.pdf", width = 4, height = 4)
ggsave("Figures/FigureXX_PairedVens.png", width = 4, height = 4)

```

Figure 4: Venn diagrams depicting number of shared significantly up-regulated / down-regulated genes. Orange venn diagrams depict up-regulated genes, while blue depicts down-regulated genes. 

<br/>
<br/>

### Full Venns of DEGs

Colleen dropped this as well

```{r full venns, eval=FALSE, include=FALSE}

## Venn of up DEGs
venn_up <- list("NS_400 vs S_2800" = upTrt_S, "S_2800 vs NS_2800" = uptrtS, "S_2800 vs NS_2800" = upsshn, "N_2800 vs S_400" = upslsh)

## Comparing down NS_400 vs S_2800 and up S_2800 vs NS_2800
venn_down <- list("NS_400 vs S_2800" = downTrt_S, "S_2800 vs NS_2800" = downsshn, "S_2800 vs NS_2800" = downtrtS)


## Plot the seperate venn diagrams
ven_up <- ggvenn(venn_up, 
       show_percentage=FALSE,
       fill_color = c("darkorange", "coral", "red", "cornsilk2"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "#C8322F", set_name_size = 2,
       )

ven_down <- ggvenn(venn_down, 
       show_percentage=FALSE,
       fill_color = c("cyan4", "cornflowerblue", "darkslategray3"), fill_alpha = 0.3,
       stroke_size = 0.4, text_size = 3, text_color = "#25292B",
       set_name_color = "blue", set_name_size = 3,
       )

## Combine and save plot
ggarrange(ven_up, ven_down)
ggsave("Figures/FigureXX_fullVens.pdf", width = 3, height = 2)
ggsave("Figures/FigureXX_fullVens.png", width = 3, height = 2)

```

Figure 5: left: four-way venn diagram showing relationships among up-regulated genes between different treatment comparisons. right: venn diagram showing relationships among down-regulated genes between treatment comparisons with significantly down-regulated genes.

<br/>
<br/>


## Gene expression plasticity {.tabset}

```{r}

mycolors <- c("#0571b0", "#ca0020", "#f4a582")

#### here is the code from the function without modifications:
## To run the function, enter the following objects:
# PCAplast(pca = XXX, # the PCA dataframe containing the PCA eigenvalues
#          data = XXX, # the condition/treatment data corresponding to samples
#          sample_ID = "XXX", # the name of column that provide unique ID per sample (if blank, will pull rownames for this)
#          num_pca =  "XXX", # the number of PCAs to include in analysis (default is 'all', but you can specify another number with a minimum of 2 PCAs)
#          control_col = "XXX", # what the 'treatment' column is called
#          control_lvl = "XXX", # control level of the treatment. If blank, a control mean per control level is assumed
#          group = "XXX") # the grouping column (i.e., colony). If blank, will assume control level grouping only!




## To run the function, enter the following objects:
ge_plast_all <-  PCAplast(pca = pcaData[6:30], # the PCA dataframe containing the PCA eigenvalues
                      data = pcaData[-6:-30], # the condition/treatment data corresponding to samples
                      num_pca =  "all", # the number of PCAs to include in analysis (default is 'all', but you can specify another number with a minimum of 2 PCAs)
                      control_col = "treat", # what the 'treatment' column is called
                      control_lvl = "N_400") # control level of the treatment. If blank, a control mean per level is assumed

#plasticity plot 1
pca_all_plot <- ggplot(data = ge_plast_all, aes(x = treat, y = dist, colour = treat, fill = treat)) + 
  geom_point(position = position_dodge(width = 0.5), aes(color = treat)) + 
  scale_colour_manual(values = mycolors) +
  scale_fill_manual(values = mycolors) +
  geom_boxplot(alpha = 0.2) +
  xlab("Treatment") +
  ggtitle("B)")


ge_plast_2 <-  PCAplast(pca = pcaData[6:30], # the PCA dataframe containing the PCA eigenvalues
                      data = pcaData[-6:-30], # the condition/treatment data corresponding to samples
                      num_pca =  "2", # the number of PCAs to include in analysis (default is 'all', but you can specify another number with a minimum of 2 PCAs)
                      control_col = "treat", # what the 'treatment' column is called
                      control_lvl = "N_400") # control level of the treatment. If blank, a control mean per level is assumed

#plasticity plot2
pca2_plot <- ggplot(data = ge_plast_2, aes(x = treat, y = dist, colour = treat, fill = treat)) + 
  geom_point(position = position_dodge(width = 0.5), aes(color = treat)) + 
  scale_colour_manual(values = mycolors) +
  scale_fill_manual(values = mycolors) +
  geom_boxplot(alpha = 0.2) +
  xlab("Treatment") +
  ggtitle("A)")

```

<br/>
<br/>

### ANOVA Tests on Plasticity Data

ANOVA test on plasticity data with 2 PCAs (looking at variable treat to see if there is any significant difference of dist)
``` {r}
# ANOVA test
res_aov <- aov(dist ~ treat,
  data = ge_plast_2
)
summary(res_aov)

TukeyHSD(res_aov, conf.level=.95)
```

ANOVA test on plasticity data with all PCAs (looking at variable treat to see if there is any significant difference of dist)
```{r}
# ANOVA test ge_plast_all
res_aov_all <- aov(dist ~ treat,
  data = ge_plast_all
)
summary(res_aov_all)

TukeyHSD(res_aov_all, conf.level=.95)
```

<br/>
<br/>

ANOVA test on plasticity data with all PCAs (looking at variable pCO2 * infect to see if there is any significant difference of dist)

```{r}
# ANOVA test ge_plast_all
res_aov_pco2_infect <- aov(dist ~ pCO2 * infect,
  data = ge_plast_all
)
summary(res_aov_pco2_infect)
res_aov_pco2_infect

TukeyHSD(res_aov_pco2_infect, conf.level=.95)
```

<br/>
<br/>

ANOVA test on plasticity data with all PCAs (looking at variable pCO2 * infect to see if there is any significant difference of dist)

```{r}
# ANOVA test ge_plast_2
res_aov_two_pco2_infect <- aov(dist ~ pCO2 * infect,
  data = ge_plast_2
)
summary(res_aov_two_pco2_infect)
res_aov_two_pco2_infect

TukeyHSD(res_aov_two_pco2_infect, conf.level=.95)
```

<br/>
<br/>

ANOVA test on plasticity data with all PCAs (looking at variable treat to see if there is any significant difference of dist)
```{r}
# ANOVA test ge_plast_all
res_aov_all <- aov(dist ~ treat,
  data = ge_plast_all
)
summary(res_aov_all)

res_aov_all

TukeyHSD(res_aov_all, conf.level=.95)
```
<br/>
<br/>

### Plasticity Plots

```{r, fig.width = 8, fig.height = 5}

# calculate mean and standard error for ge_plast_1
plasticity1_means_se <- ge_plast_all %>%  
  group_by(treat) %>% 
  summarize(mean_N=mean(dist), 
            sd_N=sd(dist), 
            N_N=n(), 
            se=sd_N/sqrt(N_N)
  ) 

# calculate mean and standard error for ge_plast_2
plasticity_means_se <- ge_plast_2 %>%  
  group_by(treat) %>% 
  summarize(mean_N=mean(dist), 
            sd_N=sd(dist), 
            N_N=n(), 
            se=sd_N/sqrt(N_N)
  ) 

#plot means and standard error
mean_se_plot <- ggplot(plasticity_means_se, aes(x=treat, y=mean_N, colour = treat)) + 
  geom_point(color = mycolors, size = 9, shape = "-") +
  geom_errorbar(aes(ymin=mean_N-se, ymax=mean_N+se), width=0.2, size=0.5, color = mycolors) +
  scale_colour_manual(values = mycolors) +
  ylab("Mean of Dist") +
  ggtitle("C)") +
  theme(legend.position = "none") +
  geom_point(data = ge_plast_2, aes(x = treat, y = dist, color = treat), alpha = 0.3)

mean_se_plot_all <- ggplot(plasticity1_means_se, aes(x=treat, y=mean_N, colour = treat)) + 
  geom_point(size = 4, color = mycolors) +
  geom_errorbar(aes(ymin=mean_N-se, ymax=mean_N+se), width=0.2, size=0.5, color = mycolors) +
  scale_colour_manual(values = mycolors, labels = c("No sponge, pCO2 2800","Sponge, pCO2 2800", "Sponge, pCO2 400"), name = "Treatment") +
  ylab("Mean of Dist") +
  theme_bw() +
  scale_x_discrete(labels= c("", "", "")) +
  xlab("Treatment") +
  ylab("Plasticity") +
  #ggtitle("D)") +
  theme(text = element_text(size = 20)) +
  geom_point(size = 3, data = ge_plast_all, aes(x = treat, y = dist, color = treat), alpha = 0.7, position = "jitter") +
  theme(axis.text.x = element_text(angle = 25, vjust = 0.6, size=15))

mean_se_plot_all

ggarrange(pca2_plot, pca_all_plot, mean_se_plot, mean_se_plot_all, common.legend = TRUE)


```

Figure 6: Assessment of plasticity (A-D) calculated as the average of the distances of each sample to the mean eigenvalue of the control (N_400). The control was omitted from this analysis. A) and C) pertains to analysis of all PCAs, while B) and D) contain analysis of 2 PCAs. A-B depicts box plots of plasticity and each individual sample as a point, while C-D shows the mean and standard error.

## Results
Infected oyster samples in the 2800 pCO2 treatment exhibited the highest plasticity (Figure __), but results from the ANOVA test with all PCAs suggest this was not statistically significant (p = 0.17, F = .967). Oysters not infected with sponge and in the 2800 treatment had the lowest plasticity (Figure _).

<br/>
<br/>


## GO for DESeq {.tabset}

```{r GO input, include = FALSE}

## create GO input dataframe
GO_DEGs <- data.frame(rn = row.names(res_trt), res_trt) %>% # make results a dataframe with rownames as column
  mutate(mutated_p = -log(pvalue)) %>% # take neg log of the p values
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p * -1, mutated_p)) %>% # change sign of data
  dplyr::select(rn, mutated_p_updown) %>% # select gene and modified p value columns only
  na.omit()


## need to rename the gene IDs with the names in the GO  file
seq2iso <- read.table("GO_MWU/GO_scripts/CVIR_seq2iso.tab")

GO_DEGs_rename <- left_join(GO_DEGs, seq2iso, by = c("rn" = "V1")) %>% 
  na.omit() %>% 
  dplyr::select(V2, mutated_p_updown)

colnames(GO_DEGs_rename) <- NULL # remove the column names


write.csv(GO_DEGs_rename, "GO_MWU/GO_files/DEG_GOinput.csv", row.names = FALSE, quote = FALSE) # save output

```

```{r GO_MWU for DEGs, eval = FALSE, include = FALSE}

### The following code was created by Mikhail V. Matz (UT Austin, February 2015; matz@utexas.edu) but was modified by Colleen B Bove (January 2022; colleenbove@gmail.com) to loop through all files at once


# GO_MWU uses continuous measure of significance (such as fold-change or -log(p-value) ) to identify GO categories that are significantly enriches with either up- or down-regulated genes. The advantage - no need to impose arbitrary significance cutoff.

# If the measure is binary (0 or 1) the script will perform a typical "GO enrichment" analysis based Fisher's exact test: it will show GO categories over-represented among the genes that have 1 as their measure. 

# On the plot, different fonts are used to indicate significance and color indicates enrichment with either up (red) or down (blue) regulated genes. No colors are shown for binary measure analysis.

# The tree on the plot is hierarchical clustering of GO categories based on shared genes. Categories with no branch length between them are subsets of each other.

# The fraction next to GO category name indicates the fracton of "good" genes in it; "good" genes being the ones exceeding the arbitrary absValue cutoff (option in gomwuPlot). For Fisher's based test, specify absValue=0.5. This value does not affect statistics and is used for plotting only.

#####################################################################################


## Edit these to match your data file names: 
goAnnotations = "CVIR_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase = "GO_MWU/GO_scripts/go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml (downloaded 06 July 2022)
iso_path = "GO_MWU/GO_scripts/" # path to GO MWU scripts
trait_path = "GO_MWU/GO_files/" # path to module files
GO_path = "GO_MWU/GO_files/Significant_GO_files/" # path to save module files with significant GO terms
figure_out_path = "GO_MWU/GO_figures/" # path where to save GO trees

# source the modified code
source("GO_MWU/GO_scripts/gomwuFunctions_CBBedits.R")


## to set custom colours
cols <- c("#0571b0","#ca0020","#92c5de","#f4a582")



#####################################################################################
############################## GO enrichment analysis ###############################
#####################################################################################

## Pull all filenames for the GO files
# two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either significant or not).
filenames <- list.files(trait_path, pattern="_GOinput.csv", full.names = FALSE)

filename <- filenames %>% 
  str_detect("CC_|MF_|BP_|MWU_|.tmp", negate = TRUE) %>%  # this is important to not include the csv files from other runs
  keep(filenames, .)

divisions <- c("CC", "MF", "BP")

for(d in divisions) {
  
  goDivision <- d # set the division
  
  for(f in filename) {
    
    input <- f # the input file name
    
    # Calculating stats
    gomwuStats(input, goDatabase, goAnnotations, goDivision, iso_path, trait_path,
               largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
               smallest=5,   # a GO category should contain at least this many genes to be considered
               clusterCutHeight=0.01, # threshold for merging similar (gene-sharing) terms. See README for details.
               #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
               #Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
               #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
    )
    
  }
}



#####################################################################################
### Identify modules with significant GO terms and save those terms to new folder ###
#####################################################################################

filenames <- list.files(trait_path, pattern="*_GOinput.csv", full.names = FALSE)

# selects the correct files for significant GO terms
filenames_sig <- filenames %>% 
  str_detect("\\MWU_", negate = FALSE) %>%
  keep(filenames, .)

for(f in filenames_sig) {
  mwu_file <- f
  mwu_out <- read.table(paste(trait_path, mwu_file, sep = ""), sep = " ", header = TRUE)
  
  str_name <- unlist(str_split(mwu_file, "_")) # split up the file name string
  goDivision <- str_name %>% str_detect("\\CC|\\MF|\\BP", negate = FALSE) %>% keep(str_name, .) # keep MWU files 
  sig_GO <- mwu_out[mwu_out$p.adj < 0.1, ] # pull the significant GO terms per module file
  GO_output <- paste(GO_path, str_name[2], "_", str_name[3], "_GOinput_sigGO.tsv", sep = "") # set the save path
  
  # saves files to path for significant GO terms
  if (nrow(sig_GO) > 0){
    sig_GO %>%  write_csv(file = GO_output)
  }
  
}



#####################################################################################
############## Plot significant GO term trees from identified modules ###############
#####################################################################################

sig_files <- list.files(GO_path, pattern = "*.tsv", full.names = FALSE)

divisions <- c("CC", "MF", "BP")

for(d in divisions) {
  #d = "CC"
  goDivision <- d # set the division
  
  sig_files_plot <- sig_files %>% 
    str_detect(goDivision, negate = FALSE) %>%
    keep(sig_files, .)
  
  for (f in sig_files_plot){
    input <- f
    str_name <- unlist(str_split(input, "_")) # split up the file name string
    GO_fig_path <- paste(figure_out_path, str_name[1], "_", str_name[2], "_tree.png", sep = "")
    
    num_terms <- nrow(read.table(paste0(GO_path, input), sep = ",")) # count # of terms for tree height
    
    if(num_terms >= 3) {
      png(GO_fig_path, height = ifelse(num_terms > 3, (num_terms/7), 0.65), width = 5, units = "in", res = 1200)
      gomwuPlot(input, goAnnotations, goDivision, iso_path, trait_path, GO_path,
                # absValue=0.001, # -log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
                absValue=1, # un-remark this if you are using log2-fold changes
                level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
                level2=0.01, # FDR cutoff to print in regular (not italic) font.
                level3=0.001, # FDR cutoff to print in large bold font.
                txtsize=1,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
                treeHeight=0.5, # height of the hierarchical clustering tree
                colors = cols
      )
      dev.off()
    } else {
      print(paste(gsub("_sigGO.tsv", "", input), "contains fewer than 3 GO terms, no tree produced"))
    }
      }
}

```

### Figure SX

**All significant GO terms identified from DEGs:**

```{r add all GO terms to markdown from PNG, results='asis', fig.align = 'center', out.width = '80%'}

files <- list.files(path = "GO_MWU/GO_figures", pattern = "png", full.names = TRUE)

for (f in files) {
  file_name <- tools::file_path_sans_ext(f) # file name without extension
  file_name <- gsub("GO_MWU/GO_figures/", "", file_name) # remove extension for file name 
  cat(paste0(file_name, ":"))
  cat(paste0("![", file_name,"](", f, ")\n"))
}

```


### All the other heatmaps!

```{r}
# launch heatmapEveryWhichWay.R to use this
uniHeatmap=function(vsd,gene.names,metric,cutoff,metric2=NA,sort=NA,pdf=TRUE,pdf.height=15,pdf.width=12,named=TRUE,pattern=NA,heat.color=colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100),...) {

	# vsd=vsd
	# gene.names=gg
	# metric=result$adjp.su
	# cutoff=1e-1
	# sort=order(surv$survival)  # overrides sorting of columns according to hierarchical clustering
	# pattern="TNF"
	# cex=0.9
	# pdf=FALSE  
	# metric2=NA
	# named=T
	# heat.color=colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)


	require(pheatmap)
	num.total=0
	select=(metric<=cutoff)
	if (!is.na(metric2)) {
		select=metric/(metric2<=cutoff)
	} 
	pdfname=paste(cutoff,"_heatmap.pdf",sep="")
	hmap=vsd[select,]
	hmap=hmap[!is.na(row.names(hmap)),]
#	length(hmap[,1])
	num.total=length(hmap[,1])
	
	# attaching gene names
	gnames=c();counts=0;num.match=0;num.named=0
	for(i in 1:length(hmap[,1])) {
		if (row.names(hmap)[i] %in% gene.names$V1) { 
			counts=counts+1
			gn=as.character(gene.names[gene.names$V1==row.names(hmap)[i],2])
			if (gn %in% gnames) {
				gn=paste(gn,counts,sep=".")
			}
			gnames=append(gnames,gn) 
		} else { 
			gnames=append(gnames,i)
		}
	} 
	row.names(hmap)=gnames
	if (named==TRUE) {
		#selecting only named genes
		hmap.n=hmap[grep('[a-z]',row.names(hmap)),]
		num.named=length(hmap.n[,1])
	}
	
	if (!is.na(pattern)){
		hmap.n=hmap[grep(pattern,gnames),]
		num.match=length(hmap.n[,1])
	}

	if (named==TRUE){
		pdfname=paste("named_",pdfname,sep="")
		if (pdf== TRUE) { pdf(pdfname,height=pdf.height,width=pdf.width) }
		if (!is.na(sort[1])) {
			hmap.n=hmap.n[,sort]
			pheatmap(hmap.n,scale="row",color=heat.color,border_color=NA,
				clustering_distance_rows="correlation",
				cluster_cols=F,...)
		} else {
			pheatmap(hmap.n,scale="row",color=heat.color,border_color=NA,
				 clustering_distance_rows="correlation",
				 clustering_distance_cols="correlation",
				 ...
				)
		}
		if (pdf==TRUE) { dev.off() }
	} else { 
		if (pdf== TRUE) { pdf(pdfname,height=pdf.height,width=pdf.width) }
		if (!is.na(sort)) {
			hmap=hmap[,order(sort)]
			pheatmap(hmap,scale="row",color=heat.color,border_color=NA,
				clustering_distance_rows="correlation",
				cluster_cols=F,...)
		} else {
			pheatmap(hmap,scale="row",color=heat.color,border_color=NA,
				 clustering_distance_rows="correlation",
				 clustering_distance_cols="correlation",
				 ...
				)
		}
		if (pdf== TRUE) { dev.off() }
	}
	return(c(num.total,num.named,num.match))
}

```


```{r fig.height = 14, fig.width = 40}

library(RColorBrewer)
library(pheatmap)

# let's take a look at some heatmaps
# scale values
filtered_vsd <- assay(vsd)
filtered_vsd <- filtered_vsd[ , c("19086", "19103", "19264", "19370", "19516", "19642", "19158", "19254", "19274", "19304", "19467", "19472", "19549")]
means <- apply(filtered_vsd,1,mean) # means of rows
norm_df_scaled <- filtered_vsd-means # rescale expression data so it's up and down
head(filtered_vsd)
df <- as.data.frame(colData(dds)[c("pCO2", "infect")])
rownames(df) <- dds@colData@rownames

df1 <- df %>%
  mutate(infect = gsub("N", "None", infect)) %>%
  mutate(infect = gsub("S", "Sponge", infect)) %>%
  filter(row.names(df) %in% c("19086", "19103", "19264", "19370", "19516", "19642", "19158", "19254", "19274", "19304", "19467", "19472", "19549"))

df1 <- df1 %>%
  arrange(factor(row.names(df1), levels = c("19086", "19103", "19264", "19370", "19516", "19642", "19158", "19254", "19274", "19304", "19467", "19472", "19549")))

#view(df1)

#display.brewer.pal(n = 4, name = 'PRGn')
#brewer.pal(n = 4, name = "PRGn")
#ann_colors <- list(
#  infect = c(N = "#A6DBA0", S = "#008837"),
#  pCO2 = c(`400` = "#C2A5CF", `2800`= "#7B3294")
#)

#ann_colors <- list(
#  infect = c(N = "#fdae61", S = "#d7191c"),
#  pCO2 = c(`400` = "#abd9e9", `2800`= "#2c7bb6")
#)

ann_colors <- list(
  infect = c(None = "#abd9e9", Sponge = "#2c7bb6"),
  pCO2 = c(`400` = "#fdae61", `2800`= "#d7191c")
)


res_trt$threshold <- as.logical(res_trt$padj< 0.1)

# Sort the results tables
res_sorted <- res_trt[order(res_trt$padj), ]

# Get significant genes
sigTrmt <- row.names(res_sorted)[which(res_sorted$threshold)]


heat_df <- data.frame(norm_df_scaled[sigTrmt,]) %>% 
  mutate(loci = rownames(data.frame(norm_df_scaled[sigTrmt,]))) %>% 
  left_join(gene,  by = c("loci" = "V1")) %>% 
  distinct(loci, .keep_all = TRUE) #%>%
  #filter(!grepl('uncharacterized', V2))

rownames(heat_df) <- heat_df$V2

colnames(heat_df) <- rownames(df1)


heat_df <- as.matrix(heat_df[1:13])

library(DEGreport)

# treatment DEGs
col= colorRampPalette(rev(c('#e66101', "#fdb863", "#fdcb8e", "#fce1c0" ,"white", '#5e3c99')),bias=0.8)(30)
pheatmapfig <- pheatmap(heat_df, color = col, cluster_cols = TRUE, clustering_distance_rows = "correlation", show_colnames = TRUE, show_rownames = TRUE, annotation_col = df1, annotation_colors = ann_colors, fontsize = 10)  
pheatmapfig
#ggsave("Figures/Pheatmap.png", height = 7, width = 14)

#pull from only N_400

```

<br/>
<br/>


## Colleen adding in WGCNA {.tabset}

```{r saving filtered count data for WGCNA, message=FALSE, warning=FALSE, include=FALSE}

## for WCGNA: removing all genes with counts <5 in more than 90 % of samples
counts4wgcna <- filter_counts_out[apply(filter_counts_out, 1, function(x) sum(x < 5)) < ncol(filter_counts_out) * 0.9,]
nrow(counts4wgcna) # 13034 genes (originally had 21957 genes)

# unhash if you want to save this data as a csv
#write.csv(counts4wgcna, file = "WGCNA/WGCNA_data/wgcna_counts.csv")

```

```{r WGCNA data modification, eval=FALSE, include=FALSE}

# takes the sample IDs, colony IDs, and factor levels from the design to create new column names for the dataframe
snames <- paste(expDesign[,5], expDesign[,1], sep = "_")

# renames the column names and save
colnames(vsd) <- snames

## more reduced stabilized dataset for WGCNA
wg <- DESeqDataSetFromMatrix(countData = counts4wgcna,
                             colData = expDesign,
                             design = ~ pCO2 + infect)

vsdWG <- assay(varianceStabilizingTransformation(wg))
#head(vsdWG, 3)

## Save the WGCNA data
colnames(vsdWG) <- snames
save(vsdWG, expDesign, file = "WGCNA/WGCNA_data/wgcna_data.RData")

```

```{r WGCNA packages and necessary lines, message=FALSE, warning=FALSE, include=FALSE}

## installing WGCNA:
# source("http://bioconductor.org/biocLite.R")
# biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
# install.packages("flashClust")
# install.packages("WGCNA",dependencies=TRUE)
# repos="http://cran.us.r-project.org"
# run these above commands once, then comment out
# always run these before running any of the WGCNA script chunks:
options(stringsAsFactors = FALSE)
allowWGCNAThreads()

```

```{r WGCNA data loading, include=FALSE, message=FALSE, warning=FALSE}

## importing data generated above 
lnames <- load("WGCNA/WGCNA_data/wgcna_data.RData")
lnames # "vsdWG"  "design" # log-transformed variance-stabilized gene expression, and table of experimental conditions
datt <- t(vsdWG)
#ncol(datt) # number of columns (13034)
#nrow(datt) # number of rows (25)

```

```{r add phys traits to exp design, eval=FALSE, include=FALSE}

## read in the phenotype data from Elise
phys_all_df <- read.csv("Data/Oyster_AllPhysData.csv", header = TRUE)

# No longer including some of these
# phys_subset_df <- phys_all_df %>% 
#   select(ID, TpCO2:Infect, BoredStart, BW2_L, BW2_W, BW2_Wt, AbsChDay02_DensCorr, CalcDay, CalcDay60, EPFpHTotal:EPFCalSat, SW, WW, DW, CI_SW, BW2_DW) %>% 
#   subset(ID %in% as.integer(as.character(expDesign$Sample_ID)))

phys_subset_df <- phys_all_df %>% 
  select(ID, TpCO2:Infect, BoredStart, BW2_L, BW2_W, BW2_Wt, CalcDay, EPFpHTotal:EPFCO3, WW, DW, BW2_DW) %>% 
  subset(ID %in% as.integer(as.character(expDesign$Sample_ID)))

write.csv(phys_subset_df, "Data/Oyster_phys_WGCNA.csv", row.names = FALSE)

```


```{r create WGCNA trait matrix, include=FALSE, message=FALSE, warning=FALSE}

## read in the phys data
phys_traits <- read.csv("Data/Oyster_phys_WGCNA.csv", header = TRUE) %>% 
  mutate(ID = factor(ID))

expDesign <- expDesign %>% 
  select(-treat) %>%
  left_join(phys_traits, by = c("Sample_ID" = "ID"))


## assembling matrix of QUANTITATIVE traits for WGCNA 
# treatments
`High pCO2` <- as.numeric(expDesign$pCO2 == "2800")
`Infected` <- as.numeric(expDesign$infect == "S")
#`N_2800` <- as.numeric(expDesign$treat == "N_2800")
#`S_400` <- as.numeric(expDesign$treat == "S_400")
#`S_2800` <- as.numeric(expDesign$treat == "S_2800")
#`N_400` <- as.numeric(expDesign$treat == "N_400")



# combine the quantitative with the qualitative for trait matrix
#traits <- cbind(`High pCO2`, `Infected`, `N_400`, `S_400`, `N_2800`, `S_2800`, expDesign[6:11])
#without treat
traits <- cbind(`High pCO2`, `Infected`, expDesign[8:20])
#colnames(traits) <- c("288_28", "311_31", "405_31", "447_28", "673_28", "701_31", "3285_28", "3300_31", "offshore", "density", "protein", "chlorophyll", "colour_intensity", "calcification", "carbohydrate", "lipid", "chlorophylla_cell", "percent_C")

```

### Mean expression across samples
```{r WGCNA outlier detection, message=FALSE, warning=FALSE}

## outlier detection and removal
# identifies outlier genes
gsg <- goodSamplesGenes(datt, verbose = 3);
gsg$allOK #if TRUE, no outlier genes

# calculates mean expression per array, then the number of missing values per array
meanExpressionByArray <- apply(datt, 1, mean, na.rm = TRUE)
NumberMissingByArray <- apply(is.na(data.frame(datt)), 1, sum)

# plots mean expression across all samples
barplot(meanExpressionByArray,
        xlab = "Sample", ylab = "Mean expression",
        main ="Mean expression across samples",
        names.arg = c(1:25), cex.names = 0.7)
# look for any obvious deviations in expression across samples

```

### Dendrogram with sample traits
```{r WGCNA outlier dendrogram, fig.height=13, fig.width=12}

# sample dendrogram and trait heat map showing outliers
A <- adjacency(t(datt), type = "signed")                 # SELECT SIGNED OR UNSIGNED HERE (use signed for WGCNA)

# this calculates the whole network connectivity
k <- (as.numeric(apply(A, 2, sum)) - 1)

# standardized connectivity
Z.k <- scale(k)
thresholdZ.k <- -2.5 # often -2.5
outlierColor <- ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree <- flashClust(as.dist(1 - A), method = "average")

# Convert traits to a color representation where red indicates high values
traitColors <- data.frame(numbers2colors(traits, signed=FALSE))
dimnames(traitColors)[[2]] <- dimnames(traits)[[2]] #paste(names(traits))
datColors <- data.frame(outlierC = outlierColor,traitColors)

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree,groupLabels = names(datColors), colors = datColors, main="Sample dendrogram and trait heatmap")

# Remove outlying samples from expression and trait data
remove_samples <- Z.k < thresholdZ.k | is.na(Z.k)
datt <- datt[!remove_samples,]
traits <- traits[!remove_samples,]
# 1 outlier detected/removed as of 12 July 2022 (sample ID: 19549)


## save updated WGCNA data/trait matrix with outliers removed
save(datt, traits, file = "WGCNA/WGCNA_data/wgcnaData_outlier.RData")
```
One sample (19611) was flagged as an outlier and removed.

```{r threshold selection and plot, fig.height=5, fig.width=12}

## This loads the updated WGCNA data from above with the two outlier samples removed
load("WGCNA/WGCNA_data/wgcnaData_outlier.RData")


# Try different betas ("soft threshold") - power factor for calling connections between genes
powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft <- pickSoftThreshold(datt, powerVector = powers, verbose = 5, networkType = "signed")

# Plot the results:
# Run from the line below to dev.off()
#sizeGrWindow(9, 5)
#pdf("WGCNA_host/WGCNA_figs/soft_threshold_signed.pdf",height=4, width=8)

par(mfrow = c(1,2));
cex1 = 0.9;

# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit, signed R^2", type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");

# this line corresponds to using an R^2 cut-off of h
abline(h = 0.90, col = "red")

# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
#dev.off()

```

```{r create dendrogram, message=FALSE, warning=FALSE, comment = FALSE, include = FALSE, eval = FALSE}

## pick the power that corresponds with a SFT.R.sq value at or above 0.90 (9 as of 12 July 2022) --> switched to 11 on 06 March 2023

# run from the line below to the save command
s.th <- 11 # specify according to previous section
adjacency <- adjacency(datt, power = s.th, type = "signed");
TOM <- TOMsimilarity(adjacency, TOMType = "signed");
dissTOM <- (1 - TOM)

# Call the hierarchical clustering function
geneTree <- flashClust(as.dist(dissTOM), method = "average")
#par(mfrow = c(1,1))
plot(geneTree, xlab = "", sub = "", main = "Gene Clustering on TOM-based dissimilarity", labels = FALSE, hang = 0.04)

# We like large modules, so we set the minimum module size relatively high:
minModuleSize <- 30;
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM,
                             deepSplit = 2, pamRespectsDendro = FALSE,
                             minClusterSize = minModuleSize);
dynamicColors <- labels2colors(dynamicMods)
#table(dynamicColors)

# Calculate eigengenes
MEList <- moduleEigengenes(datt, colors = dynamicColors)
MEs <- MEList$eigengenes
# the grey module contains unassigned genes and is not considered a real module

# if you have error messages trying to generate the eigengene correlations, run this below
# check MEs, if grey shows NaN for all samples, then make sure to eliminate it using removeGreyME
# MEs = removeGreyME(MEs, greyMEName = paste(moduleColor.getMEprefix(), "grey", sep=""))

# Calculate dissimilarity of module eigengenes
MEDiss <- 1 - cor(MEs);
METree <- flashClust(as.dist(MEDiss), method = "average");


## This saves the first pass data (hash it out when running with merges)
save(dynamicMods, dynamicColors, MEs, METree, geneTree, file = "WGCNA/WGCNA_data/1stPassModules.RData")

```

```{r clustering tree, message=FALSE, warning=FALSE}

## s2t the cutoff
MEDissThres <- 0.51 # using 0.4 as of 12 July 2022 # in the first pass, set this to 0 - no merging (we want to see the module-traits heatmap first, then decide which modules are telling us the same story and better be merged)

mm <- load('WGCNA/WGCNA_data/1stPassModules.RData')
lnames <- load('WGCNA/WGCNA_data/wgcnaData_outlier.RData')
# traits
# head(datt)

## saved version of module cluster tree
pdf(file = "WGCNA/WGCNA_figures/ClusterTree.pdf", width = 8, height = 5)
#sizeGrWindow(7, 6)
plot(METree, xlab = "", sub = "")
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")  # on 2nd pass: does this cut height meet your merging goals? If not, reset MEDissThres and replot
dev.off()

## plot for the markdown document
plot(METree, xlab = "", sub = "")
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")  # on 2nd pass: does this cut height meet your merging goals? If not, reset MEDissThres and replot


# Call an automatic merging function
merge <- mergeCloseModules(datt, dynamicColors, cutHeight = MEDissThres, verbose = 3)

# The merged module colors
mergedColors <- merge$colors;

# Eigengenes of the new merged modules:
mergedMEs <- merge$newMEs

```

```{r merged dendrogram, message=FALSE, warning=FALSE, comment=FALSE, fig.height=10}

# plotting the fabulous ridiculogram
pdf(file = "WGCNA/WGCNA_figures/ClusterDendrogram.pdf", height = 4.5, width = 8.5)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = FALSE, guideHang = 0.05,lwd=0.3)
dev.off()

# plot for markdown
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = FALSE, guideHang = 0.05,lwd=0.3)

# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;

# Calculate dissimilarity of module eigengenes
#
# the grey module contains unassigned genes and is not considered a real module
# if you have error messages trying to generate the eigengene correlations, run this below
# check MEs, if grey shows NaN for all samples, then make sure to eliminate it using removeGreyME
# MEs = removeGreyME(MEs, greyMEName = paste(moduleColor.getMEprefix(), "grey", sep=""))
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = flashClust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree, xlab = "Merged modules", sub = "")

# how many genes in each module?
#table(moduleColors)


# Save module colors and labels for use in subsequent parts
save(MEs, geneTree, moduleLabels, moduleColors, file = "WGCNA/WGCNA_data/networkdata_signed.RData")

```

Figure: Cluster Dendrogram

### Heatmap and gene bar graph

```{r heatmap of modules, message=FALSE, warning=FALSE, fig.height = 5.8, fig.width = 9}

# plotting correlations with traits:
load(file = "WGCNA/WGCNA_data/networkdata_signed.RData")
load(file = "WGCNA/WGCNA_data/wgcnaData_outlier.RData");

# Define numbers of genes and samples
nGenes <- ncol(datt);
nSamples <- nrow(datt);

# Recalculate MEs with color labels
MEs0 <- moduleEigengenes(datt, moduleColors)$eigengenes
MEs <- orderMEs(MEs0)

# correlations of genes with eigengenes
moduleGeneCor <- cor(MEs, datt)
moduleGenePvalue <- corPvalueStudent(moduleGeneCor, nSamples);
moduleTraitCor <- cor(MEs, traits, use = "p");
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples);

# module-trait correlations
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) <- dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));

#table(moduleColors) # gives numbers of genes in each module

# shows only significant correlations
modLabels <- sub("ME","",names(MEs))
ps <- signif(moduleTraitPvalue,1)
cors <- signif(moduleTraitCor,2)
textMatrix <-  cors;
textMatrix[ps>0.05]="-"
dim(textMatrix) <- dim(moduleTraitCor)

```

```{r save WGCNA  output}

# if it was first pass with no module merging, this is where you examine your heatmap
# and dendrogram of module eigengenes to see
# where you would like to set cut height (MEDissThres parameter) in the previous section
# to merge modules that are telling the same story for your trait data
# good way to do it is to find a group of similar modules in the heat map and then see
# at which tree height they connect in the dendrogram.

#####################
## This saves everything that you need to create gene scatter plots, heat maps, and GO MWU files from all significant module/trait pairings
save(datt, moduleTraitPvalue, moduleColors, MEs, traits, vsdWG, file = "WGCNA/WGCNA_data/wgcnaMods.RData")

```

```{r markdown heatmap figure}

mod_df <- data.frame(module = row.names(moduleTraitCor), moduleTraitCor) %>% 
  gather("trait", "corr", -module, factor_key = TRUE) %>% 
  mutate(module = factor(module, levels = rownames(moduleTraitCor))) %>% 
  mutate(module = fct_rev(module))

mod_pval_df <- data.frame(module = row.names(ps), ps) %>% 
  gather("trait", "pval", -module, factor_key = TRUE) %>% 
  mutate(module = factor(module, levels = rownames(ps))) %>% 
  mutate(module = fct_rev(module))
  
mod_df <- mod_df %>% 
  add_column(lab = mod_pval_df$pval) %>% 
  mutate(lab = ifelse(lab > 0.05, "-", round(corr,2)))


#### Heatmap of modules from WGCNA
heatmap <- ggplot(data = mod_df, aes(x = trait, y = module, fill = corr)) +
  theme_bove() +
  geom_tile() +
  geom_text(aes(label = lab), color = "#2f2f2f", size = 3) +
  scale_fill_gradient2(low = "#2166ac", mid = "#FFFFFF", high = "#b2182b") +
  theme(legend.position = "right", legend.title = element_text(size = 12), plot.margin = margin(10, 10, 10, 150)) + 
  theme(axis.ticks = element_blank(), axis.title = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  # theme(axis.ticks = element_blank(), axis.text.y = element_blank(), axis.title = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_x_discrete(labels = colnames(moduleTraitCor)) +
  guides(fill = guide_colourbar(barwidth = 0.7, barheight = 10, frame.colour = "black", ticks.colour = "black", title = expression(paste("Pearson", " R"^{2})))) +
  coord_cartesian(expand = FALSE)


#### barplot of genes within each module
mct <- table(moduleColors)
modLabels_plot <- as.data.frame(mct[rev(modLabels)])
modLabels_plot2 <- as.character(modLabels_plot$moduleColors)
#modLabels2 <- gsub("turquoise", "teal", modLabels_plot2)

library(cowplot)

barplot <- ggplot(data = modLabels_plot, aes(y = Freq, x = moduleColors, fill = moduleColors)) +
  geom_col(colour = "black", size = 0.1) +
  scale_fill_manual(values = modLabels_plot2) +
  theme_cowplot() +
  coord_flip(expand = FALSE) +
  scale_y_reverse(limits=c(8000, 0), breaks = c(1000, 2000, 3000)) +
  geom_text(aes(label = paste0(rev(modLabels), " (", Freq, ")")), hjust = 1.05, color="black", size = 10) +
  theme(axis.ticks.y = element_blank(), axis.title.y = element_blank(), legend.position = "none", axis.line.y = element_blank(), axis.line.x = element_line(size = 0.2), axis.text.y = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, size = 10), axis.title.x = element_text(size = 10)) +
  ylab("# genes\n per module")

```

```{r plot and save WGCNA with bars, fig.height = 5.8, fig.width = 10}

heatmap #+ 
 #annotation_custom(ggplotGrob(barplot), xmin = -6, xmax = 0.75, ymin = -6, ymax = 67) + 
 #theme(plot.background = element_rect(fill = "white", colour = NA))

#ggsave(file = "Figures/Main_figures/Figure4_WGCNA.pdf", height = 5.8, width = 10, units = "in", dpi = 1200)
#ggsave(file = "Figures/Main_figures/Figure4_WGCNA.png", height = 5.8, width = 10, units = "in", dpi = 1200)

```



```{r wgcna mod/trait plots and files, eval=FALSE, include=FALSE}

## Load all the required objects for running the module/trait function
load(file = "WGCNA/WGCNA_data/wgcnaMods.RData")
load(file = "WGCNA/WGCNA_data/networkdata_signed.Rdata")
load(file = "WGCNA/WGCNA_data/wgcna_data.RData")


## A couple things to do before running functions
nGenes <- ncol(datt) # extract number of genes; (datt = transposed VSD transformed count data)
nSamples <- nrow(datt) # extract number of samples; (datt = transposed VSD transformed count data)
modNames <- substring(names(MEs), 3) # string of all module names 

geneModuleMembership <- as.data.frame(signedKME(datt, MEs));
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) <- paste("MM", modNames, sep="");
names(MMPvalue) <- paste("p.MM", modNames, sep="")


## Select the significant trait/module pairings from the WGCNA heatmap 
traitMods <- sigMods(matrix = moduleTraitPvalue) ## **NOTE: default alpha is set you 0.05 but can be adjusted by specifying 'alpha = XX' here


# Running the below function will create the following: 
## - Data frame of Gene Trait Significance ("GTSig") and Gene Significance P values ("GSPvalue") for each trait/module
## - List containing all the ggplot objects for each module/trait correlation plot ("CorrPlots")
## - List containing all the ggplot objects for each module/trait heatmap/bar plot ("Heatmaps")
## - Saves pngs of all plots within both "CorrPlots" and "Heatmaps"
## - Saves selected modules as csv files for GO and KOG analysis (both as kME values and binary (presence/absence) files)
ModWGCNA_out <- ModWGCNA(wgcna_data = datt,
                         traitMods = traitMods,
                         traits = traits,
                         geneModuleMembership = geneModuleMembership,
                         MEs = MEs, 
                         vsdWG = vsdWG,
                         corrplotpath = "WGCNA/WGCNA_figures/ClusterPlots/", ## you need create this directory first!
                         heatplotpath = "WGCNA/WGCNA_figures/HeatMaps/", ## you need create this directory first!
                         goMWUpath = "WGCNA/WGCNA_GO/WGCNA_GO_files/") ## you need create this directory first!


## Save the WGCNA Trait/module output list populated in function code chunk above
saveRDS(object = ModWGCNA_out, file = "WGCNA/WGCNA_data/wgcna_TraitMod_plots.rds")

```

```{r GO enrichment, eval=FALSE, include=FALSE}

# GO_MWU uses continuous measure of significance (such as fold-change or -log(p-value) ) to identify GO categories that are significantly enriches with either up- or down-regulated genes. The advantage - no need to impose arbitrary significance cutoff.

# If the measure is binary (0 or 1) the script will perform a typical "GO enrichment" analysis based Fisher's exact test: it will show GO categories over-represented among the genes that have 1 as their measure. 

# On the plot, different fonts are used to indicate significance and color indicates enrichment with either up (red) or down (blue) regulated genes. No colors are shown for binary measure analysis.

# The tree on the plot is hierarchical clustering of GO categories based on shared genes. Categories with no branch length between them are subsets of each other.

# The fraction next to GO category name indicates the fracton of "good" genes in it; "good" genes being the ones exceeding the arbitrary absValue cutoff (option in gomwuPlot). For Fisher's based test, specify absValue=0.5. This value does not affect statistics and is used for plotting only.


# Mikhail V. Matz, UT Austin, February 2015; matz@utexas.edu 
## UPDATED BY: Colleen B Bove, August 2021; colleenbove@gmail.com

################################################################

### ANGELA WRITE IT HERE:

# files you want:  CVIR_iso2go.tab and CVIR_seq2iso.tab

iss=read.table("WGCNA/WGCNA_GO/WGCNA_GO_scripts/CVIR_iso2go.tab",sep="\t",check.names=F)
seq2iso=read.table("WGCNA/WGCNA_GO/WGCNA_GO_scripts/CVIR_seq2iso.tab",sep="\t",check.names=F)

iss <- iss %>%
  rename(V1 = "sequence", V2 = "GO_term")

seq2iso <- seq2iso %>%
  rename(V1 = "loci", V2 = "sequence")

test <- cbind(iss, loci = seq2iso$loci)
test <- test %>%
  filter(!(GO_term == "")) %>%
  select(-sequence)

test <- test[, c("loci", "GO_term")]

haplotigs <- read.table("Haplotig_gene_mRNA_CDS_identifiers.tab",sep="\t",check.names=F)
haplotigs <- haplotigs %>%
  rename(Attr.Parent.. = "loci") %>%
  filter(grepl('LOC', loci))

remove_haplotigs <- merge(haplotigs, seq2iso, by = "loci", all = T)

remove_haplotigs <- remove_haplotigs %>%
  filter(Haplotig_Flag == "Not_Haplotig")

haplotigs_removed <- merge(test, haplotigs, by = "loci")
haplotigs_removed <- haplotigs_removed %>%
  select(c(loci, GO_term))

haplotigs_removed <- unique(haplotigs_removed)

write.table(haplotigs_removed, "WGCNA/WGCNA_GO/WGCNA_GO_scripts/CVIR_gene2go.tab", sep = "\t", col.names=FALSE, row.names = FALSE, quote = FALSE)

#write.table(data.frame(x = 1), "WGCNA/WGCNA_GO/WGCNA_GO_scripts/CVIR_gene2go.tab", quote = FALSE)

#####


# Edit these to match your data file names: 
goAnnotations = "CVIR_gene2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase = "WGCNA/WGCNA_GO/WGCNA_GO_scripts/go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
iso_path = "WGCNA/WGCNA_GO/WGCNA_GO_scripts/" # path to GO MWU scripts
trait_path = "WGCNA/WGCNA_GO/WGCNA_GO_files/" # path to module files
GO_path = "WGCNA/WGCNA_GO/WGCNA_GO_files/Significant_GO_files/" # path to save module files with significant GO terms
figure_out_path = "WGCNA/WGCNA_GO/WGCNA_GO_figures/" # path where to save GO trees
source("GO_MWU/GO_scripts/gomwuFunctions_CBBedits.R")


#####################################################################################
############################## GO enrichment analysis ###############################
#####################################################################################

## Pull all filenames for the binary (presence/absence) WGCNA files
# two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
filenames <- list.files(trait_path, pattern="*_binary.csv", full.names = FALSE)

filename <- filenames %>% 
  str_detect("CC_|MF_|BP_|MWU_", negate = TRUE) %>%  # this is important to not include the csv files from other runs
  keep(filenames, .)

divisions <- c("CC", "MF", "BP")
#divisions <- c("CC") # a test run with just 1 div to see how it works

for(d in divisions) {
  
  goDivision <- d # set the division
  
  for(f in filename) {
    #input <- "darkturquoise_binary.csv"
    input <- f # the input file name
    
    # Calculating stats
    gomwuStats(input, goDatabase, goAnnotations, goDivision, iso_path, trait_path,
               largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
               smallest=5,   # a GO category should contain at least this many genes to be considered
               clusterCutHeight=0.30, # threshold for merging similar (gene-sharing) terms. See README for details.
               #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
               Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
               #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
    )
    
  }
}



#####################################################################################
### Identify modules with significant GO terms and save those terms to new folder ###
#####################################################################################

filenames <- list.files(trait_path, pattern="*_binary.csv", full.names = FALSE)

# selects the correct files for significant GO terms
filenames_sig <- filenames %>% 
  str_detect("\\MWU_", negate = FALSE) %>%
  keep(filenames, .)

for(f in filenames_sig) {
  mwu_file <- f
  mwu_out <- read.table(paste(trait_path, mwu_file, sep = ""), sep = " ", header = TRUE)
  
  str_name <- unlist(str_split(mwu_file, "_")) # split up the file name string
  goDivision <- str_name %>% str_detect("\\CC|\\MF|\\BP", negate = FALSE) %>% keep(str_name, .) # keep MWU files 
  sig_GO <- mwu_out[mwu_out$p.adj < 0.1, ] # pull the significant GO terms per module file
  GO_output <- paste(GO_path, str_name[2], "_", str_name[3], "_binary_sigGO.tsv", sep = "") # set the save path
  
  # saves files to path for significant GO terms
  if (nrow(sig_GO) > 0){
    sig_GO %>%  write_csv(file = GO_output)
  }
  
}


#####################################################################################
############## Plot significant GO term trees from identified modules ###############
#####################################################################################

sig_files <- list.files(GO_path, pattern = "*.tsv", full.names = FALSE)

#divisions <- c("CC")

for(d in divisions) {
  #d = "CC"
  goDivision <- d # set the division
  
  sig_files_plot <- sig_files %>% 
    str_detect(goDivision, negate = FALSE) %>%
    keep(sig_files, .)

  for (f in sig_files_plot){
    #f = "BP_blue_binary_sigGO.tsv"
    input <- f
    str_name <- unlist(str_split(input, "_")) # split up the file name string
    GO_fig_path <- paste(figure_out_path, str_name[1], "_", str_name[2], "_tree.png", sep = "")
    
    num_terms <- nrow(read.table(paste0(GO_path, input), sep = ",")) # count # of terms for tree height

    if(num_terms >= 3) {
      png(GO_fig_path, height = ifelse(num_terms > 3, (num_terms/7), 0.65), width = 5, units = "in", res = 1200)
      gomwuPlot(input, goAnnotations, goDivision, iso_path, trait_path, GO_path,
                absValue=0.001, # -log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
                #	absValue=1, # un-remark this if you are using log2-fold changes
                level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
                level2=0.01, # FDR cutoff to print in regular (not italic) font.
                level3=0.001, # FDR cutoff to print in large bold font.
                txtsize=1,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
                treeHeight=0.5 # height of the hierarchical clustering tree
                #colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
      )
      dev.off()
    } else {
      print(paste(gsub("_sigGO.tsv", "", input), "contains fewer than 3 GO terms, no tree produced"))
    }
      }
}

```


<br/>
<br/>

### WGCNA correlation plots

```{r load ModWGCNA_out}

## Load the WGCNA Trait/module output list populated in function code chunk above
ModWGCNA_out <- readRDS(file = "WGCNA/WGCNA_data/wgcna_TraitMod_plots.rds")

```

```{r plot all corr plots, fig.height=round((length(ModWGCNA_out[["CorrPlots"]]) / 1.6) + 5), fig.width = 12}

## plot of all the correlation plots from WGCNA traits
grid.arrange(grobs = ModWGCNA_out[["CorrPlots"]], ncol = 3)

```

**Figure SXX.** All identified WGCNA modules correlated against significant traits with *R^2^* and p values. 

<br/>
<br/>


### WGCNA heatmaps

```{r plot all heatmaps, fig.height=(length(ModWGCNA_out[["CorrPlots"]]) * 4), fig.width = 12}

## plot of all the heatmap plots from WGCNA traits
grid.arrange(grobs = ModWGCNA_out[["Heatmaps"]], ncol = 2)

```

**Figure SXX.** Heatmap and barplots of samples for all significant traits identified within each WGCNA module. 


```{r add all module trees to markdown from PNG, results='asis', fig.align = 'center', out.width = '80%'}

files <- list.files(path = "WGCNA/WGCNA_GO/WGCNA_GO_figures", pattern = "png", full.names = TRUE)

for (f in files) {
  file_name <- tools::file_path_sans_ext(f) # file name without extension
  file_name <- gsub("WGCNA/WGCNA_GO/WGCNA_GO_figures/", "", file_name) # remove extension for file name 
  cat(paste0(file_name, ":"))
  cat(paste0("![", file_name,"](", f, ")\n"))
}

```

<br/>
<br/>

  
## Session Information

Session information from the last full knit of Rmarkdown on `r format(Sys.time(), '%d %B %Y')`.

```{r session info}

sessionInfo()

```